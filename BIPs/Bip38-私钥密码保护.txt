						私钥密码保护

概要：
    一种以58位可打印字符形式加密和编码保存比特币私钥的方法已经提出。
    加密后的私钥字符串打算用于纸钱包和实物形式的比特币。字符串中包含了除密码外其它一切用于复原私钥的信息，并且这种方法使用“加盐”和“scrypt”算法来抵抗暴力破解。
	
	这种方法提供了两种编码方式：
		一种允许任何一致的私钥可以被任何的密码加密。
		另一种允许一个在提供了 部分最终生成的字符串和相关联的比特币地址，以及一个原密码衍生的字符串时生成共享的私钥的方案。完整的原密码只有在需要将关联的比特币地址中的币进行使用时才需要提供。

	一个32位的hash形式的比特币地址是没有进行任何加密的，因此它可以在不知道密码的情况下以一个合理的概率和一个比特币地址进行关联。完整的比特币地址可以根据对加密记录进行成功的解密后衍生处理。


动机：
	这个提议源于对于物理比特币和纸钱包使用的观察。
	一个实物比特币的发行人必须是值得信赖和信任的。尽管是值得信赖的，但是用户对一个理论上能够拿走他们资金的第三方持怀疑态度是很正确的。一个实物比特币的价值不能超出它的发行者所能提供的总价值。


规范：
	生成过程会涉及到以下函数和定义：
		AES256加解密：不考虑初始化向量或块链接的AES块加密的简易形式。使用256位的key和16位的输入，生成固定的16位输出。
		SHA256：一个知名的hash算法，将任意数量的输入产生固定的32位输出。
		scrypt：使用以下参数：password(string)、salt(string)、n(int)、r(int)、p(int)、length(int)，生成length参数所指定长度的结果。
		ECMultiply：secp256k1椭圆曲线的乘法处理。
		G，N：secp256k1椭圆曲线定义中的一部分。G是椭圆曲线上的一个点，N是一个大的正整数。
		Base58Check：在比特币体系中常用的，使用58个字符数字对byte数组进行编码的方式。
	

前缀：
	Base58Check编码后的结果，建议生成以“6”开头的字符串。“6”代表了，在使用者的角度，“一个需要处理后才能使用的私钥”-这是一个保护性的定义，在将来包容参与多签的key时更好理解。同时，也是选择处理和现存的，普遍用于未加密的私钥“5”开头的地址进行区分。
	同时提出第二个字符应该标识出所需要的第二个因子，以一个大写的P标识是加密的key需要一个密码进行处理。
	
	为了保持key加密后的大小，在AES加密中使用了未初始化的向量(IVs)。而用于“IV-like”的合适的值，则靠以密码和比特币地址的32位hast结果为salt，使用scrypt方法进行衍生。


规范建议：
	对象前缀标识符：0x0142（non-EC-multiplied），0x0143(EC-multiplied)
		这些固定字节出现在Base58编码的开头，并且使得结果字符串有着固定的前缀。

	为什么58位字符串总是以“6P”开头
		原因在于用于标识“EC-multiply”和压缩标识的第三个字符。

	除前缀外的有效字节长度：37
		1位：标志位
			为了保持“6P”的前缀，最多只能使用2位来保存压缩标识。对于“non-EC-multiplied”，使用“11”；对于“EC-multiplied”，使用00。
			“0x20”标识对应的key需要使用压缩的公钥形式转换为比特币地址。
			“0x10”和“0x08”作为保留值，为未来的实现进行考虑：用于多签中可以进行单签而不必所有因素参与（1/2？）。为了遵守当前版本规范，这些字节必须都是0。
			“0x04”标识是否有大量有序的数组被放在第一个因素中。 并用于在解码过程中激活特殊行为。该标识仅用于“EC-multiplied”中使用，“non-EC-multiplied”中必须是“0”。
		4位：SHA256(SHA256(expected_bitcoin_address))结果的前4位，作为错误校验和盐使用。
		16位：内容依赖于是否使用了“EC multiplication”。
		16位：AES对key加密后的结果（依赖于是否使用了“EC multiplication”）。

	
不使用“EC multiply”标志时的生成方法：
	不使用“EC multiply”的加密可以对任何一致的私钥进行加密。加密过程必须知道密码。
	步骤：
		1. 获取比特币地址，并且计算addresshash = SHA256(SHA256(address))，取其前4位。
		2. 使用scrypt计算一个key。
			byte[] result = SCrypt.scrypt(password.getBytes(), addresshash, n, r, p, length);
			* 其中：n=16384, r=8, p=8, length=64。
			将64位的result分为32位的两部分，derivedhalf1和derivedhalf2。
		3. encryptedhalf1 = AES256Encrypt(block = bitcoinprivkey[0...15] xor derivedhalf1[0...15], key = derivedhalf2)
		4. encryptedhalf2 = AES256Encrypt(block = bitcoinprivkey[16...31] xor derivedhalf1[16...31], key = derivedhalf2)
		5. 组合：0x01 0x42 + flagbyte + salt + encryptedhalf1 + encryptedhalf2
				




